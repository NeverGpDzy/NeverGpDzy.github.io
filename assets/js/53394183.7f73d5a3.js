"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[753],{4600:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>m,contentTitle:()=>a,default:()=>d,frontMatter:()=>p,metadata:()=>o,toc:()=>s});var r=n(4848),i=n(8453);const p={},a="\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",o={id:"DataStructer/\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",title:"\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",description:"\u4ee3\u7801",source:"@site/docs/DataStructer/\u6570\u636e\u7ed3\u678419-\u6392\u5e8f.md",sourceDirName:"DataStructer",slug:"/DataStructer/\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",permalink:"/docs/DataStructer/\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"DataStructerSidebar",previous:{title:"\u6570\u636e\u7ed3\u678418-\u54c8\u5e0c\u8868",permalink:"/docs/DataStructer/\u6570\u636e\u7ed3\u678418-\u54c8\u5e0c\u8868"}},m={},s=[{value:"\u4ee3\u7801",id:"\u4ee3\u7801",level:2}];function l(t){const e={code:"code",h1:"h1",h2:"h2",pre:"pre",...(0,i.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"\u6570\u636e\u7ed3\u678419-\u6392\u5e8f",children:"\u6570\u636e\u7ed3\u678419-\u6392\u5e8f"}),"\n",(0,r.jsx)(e.h2,{id:"\u4ee3\u7801",children:"\u4ee3\u7801"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"/**\n * Hash table.\n * \n * @author Fan Min minfanphd@163.com.\n */\n#include <stdio.h>\n#include <malloc.h>\n#include <stdbool.h>\n\n#define TABLE_SIZE 19\n\n/**\n * <key, value> pair.\n */\ntypedef struct Node{\n\tint key;\n\tchar value;\n}Node, *NodePtr;\n\n/**\n * <key, value> pair.\n */\ntypedef struct SequentialList{\n\tint length;\n\tNodePtr elements;\n}SequentialList, *ListPtr;\n\n/**\n * Initialize a data array.\n */\nListPtr initList(int* paraKeys, char* paraValues, int paraLength){\n\tint i;\n\tListPtr resultPtr = (ListPtr)malloc(sizeof(struct SequentialList));\n\tresultPtr->length = paraLength;\n\tresultPtr->elements = (NodePtr)malloc(paraLength * sizeof(struct Node));\n\tfor (i = 0; i < paraLength; i ++){\n\t\t//printf(\"setting key for index %d: %d and value: %c\\r\\n\", i, paraKeys[i], paraValues[i]);\n\t\tresultPtr->elements[i].key = paraKeys[i];\n\t\tresultPtr->elements[i].value = paraValues[i];\n\t}//Of for i\n\n\treturn resultPtr;\n}//Of initList\n\n/**\n * Print the list.\n */\nvoid printList(ListPtr paraPtr) {\n\tint i;\n\tprintf(\"(Keys, values)\\r\\n\");\n\tfor (i = 0; i < paraPtr->length; i ++) {\n\t\tprintf(\"%d\\t\", paraPtr->elements[i].key);\n\t}//Of for i\n\tprintf(\"\\r\\n\");\n\tfor (i = 0; i < paraPtr->length; i ++) {\n\t\tprintf(\"%c\\t\", paraPtr->elements[i].value);\n\t}//Of for i\n}//Of printList\n\n/**\n * Insertion sort. paraPtr->elements[0] does not store a valid data. paraPtr->elements[0].key should\n * be smaller than any valid key.\n */\nvoid insertionSort(ListPtr paraPtr) {\n\tNode tempNode;\n\tint j;\n\tfor (int i = 2; i < paraPtr->length; i++) {\n\t\ttempNode = paraPtr->elements[i];\n\t\t\n\t\t//Find the position to insert.\n\t\t//At the same time, move other nodes.\n\t\tfor (j = i - 1; paraPtr->elements[j].key > tempNode.key; j--) {\n\t\t\tparaPtr->elements[j + 1] = paraPtr->elements[j];\n\t\t} // Of for j\n\t\t\n\t\t//Insert.\n\t\tparaPtr->elements[j + 1] = tempNode;\n\t} // Of for i\n}// Of insertionSort\n\n/**\n * Test the method.\n */\nvoid insertionSortTest() {\n\tint tempUnsortedKeys[] = { -100, 5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = { 'n', 'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 8);\n\n\tprintf(\"\\r\\nBefore insertion sort:\\r\\n\");\n\tprintList(tempList);\n\n\tinsertionSort(tempList);\n\tprintf(\"\\r\\nAfter insertion sort:\\r\\n\");\n\tprintList(tempList);\n}// Of insertionSortTest\n \n/**\n * Shell sort.\n */\nvoid shellSort(ListPtr paraPtr) {\n\tNode tempNode;\n\tint tempJumpArray[] = { 5, 3, 1 };\n\tint tempJump;\n\tint p, i, j, k;\n\tfor (i = 0; i < 3; i++) {\n\t\ttempJump = tempJumpArray[i];\n\t\tfor (j = 0; j < tempJump; j++) {\n\t\t\tfor (k = j + tempJump; k < paraPtr->length; k += tempJump) {\n\t\t\t\ttempNode = paraPtr->elements[k];\n\t\t\t\t// Find the position to insert.\n\t\t\t\t// At the same time, move other nodes.\n\t\t\t\tfor (p = k - tempJump; p >= 0; p -= tempJump) {\n\t\t\t\t\tif (paraPtr->elements[p].key > tempNode.key) {\n\t\t\t\t\t\tparaPtr->elements[p + tempJump] = paraPtr->elements[p];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // Of if\n\t\t\t\t} // Of for p\n\n\t\t\t\t// Insert.\n\t\t\t\tparaPtr->elements[p + tempJump] = tempNode;\n\t\t\t} // Of for k\n\t\t} // Of for j\n\t} // Of for i\n}// Of shellSort\n\n/**\n * Test the method.\n */\nvoid shellSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore shell sort:\\r\\n\");\n\tprintList(tempList);\n\n\tshellSort(tempList);\n\tprintf(\"\\r\\nAfter shell sort:\\r\\n\");\n\tprintList(tempList);\n}// Of shellSortTest\n\n/**\n * Bubble sort.\n */\nvoid bubbleSort(ListPtr paraPtr) {\n\tbool tempSwapped;\n\tNode tempNode;\n\tint i, j;\n\tfor (i = paraPtr->length - 1; i > 0; i--) {\n\t\ttempSwapped = false;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (paraPtr->elements[j].key > paraPtr->elements[j + 1].key) {\n\t\t\t\t// Swap.\n\t\t\t\ttempNode = paraPtr->elements[j + 1];\n\t\t\t\tparaPtr->elements[j + 1] = paraPtr->elements[j];\n\t\t\t\tparaPtr->elements[j] = tempNode;\n\n\t\t\t\ttempSwapped = true;\n\t\t\t} // Of if\n\t\t} // Of for j\n\n\t\t// No swap in this round. The data are already sorted.\n\t\tif (!tempSwapped) {\n\t\t\tprintf(\"Premature.\\r\\n\");\n\t\t\tbreak;\n\t\t} // Of if\n\t} // Of for i\n}// Of bubbleSort\n\n/**\n * Test the method.\n */\nvoid bubbleSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore bubble sort:\\r\\n\");\n\tprintList(tempList);\n\n\tshellSort(tempList);\n\tprintf(\"\\r\\nAfter bubble sort:\\r\\n\");\n\tprintList(tempList);\n}// Of bubbleSortTest\n\n/**\n * Quick sort recursive.\n */\nvoid quickSortRecursive(ListPtr paraPtr, int paraStart, int paraEnd) {\n\tint tempPivot, tempLeft, tempRight;\n\tNode tempNodeForSwap;\n\t\n\t// Nothing to sort.\n\tif (paraStart >= paraEnd) {\n\t\treturn;\n\t} // Of if\n\n\ttempPivot = paraPtr->elements[paraEnd].key;\n\t\n\ttempLeft = paraStart;\n\ttempRight = paraEnd - 1;\n\n\t// Find the position for the pivot.\n\t// At the same time move smaller elements to the left and bigger one to the\n\t// right.\n\twhile (true) {\n\t\twhile ((paraPtr->elements[tempLeft].key < tempPivot) && (tempLeft < tempRight)) {\n\t\t\ttempLeft++;\n\t\t} // Of while\n\n\t\twhile ((paraPtr->elements[tempRight].key >= tempPivot) && (tempLeft < tempRight)) {\n\t\t\ttempRight--;\n\t\t} // Of while\n\n\t\tif (tempLeft < tempRight) {\n\t\t\t// Swap.\n\t\t\t//System.out.println(\"Swapping \" + tempLeft + \" and \" + tempRight);\n\t\t\ttempNodeForSwap = paraPtr->elements[tempLeft];\n\t\t\tparaPtr->elements[tempLeft] = paraPtr->elements[tempRight];\n\t\t\tparaPtr->elements[tempRight] = tempNodeForSwap;\n\t\t} else {\n\t\t\tbreak;\n\t\t} // Of if\n\t} // Of while\n\n\t// Swap\n\tif (paraPtr->elements[tempLeft].key > tempPivot) {\n\t\ttempNodeForSwap = paraPtr->elements[paraEnd];\n\t\tparaPtr->elements[paraEnd] = paraPtr->elements[tempLeft];\n\t\tparaPtr->elements[tempLeft] = tempNodeForSwap;\n\t} else {\n\t\ttempLeft++;\n\t} // Of if\n\n\t//System.out.print(\"From \" + paraStart + \" to \" + paraEnd + \": \");\n\t//System.out.println(this);\n\n\tquickSortRecursive(paraPtr, paraStart, tempLeft - 1);\n\tquickSortRecursive(paraPtr, tempLeft + 1, paraEnd);\n}// Of quickSortRecursive\n\n/**\n * Quick sort.\n */\nvoid quickSort(ListPtr paraPtr) {\n\tquickSortRecursive(paraPtr, 0, paraPtr->length - 1);\n}// Of quickSort\n\n/**\n * Test the method.\n */\nvoid quickSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore quick sort:\\r\\n\");\n\tprintList(tempList);\n\n\tquickSort(tempList);\n\tprintf(\"\\r\\nAfter quick sort:\\r\\n\");\n\tprintList(tempList);\n}// Of quickSortTest\n\n/**\n * Selection sort.\n */\nvoid selectionSort(ListPtr paraPtr) {\n\tNode tempNode;\n\tint tempIndexForSmallest, i, j;\n\n\tfor (i = 0; i < paraPtr->length - 1; i++) {\n\t\t// Initialize.\n\t\ttempNode = paraPtr->elements[i];\n\t\ttempIndexForSmallest = i;\n\t\tfor (j = i + 1; j < paraPtr->length; j++) {\n\t\t\tif (paraPtr->elements[j].key < tempNode.key) {\n\t\t\t\ttempNode = paraPtr->elements[j];\n\t\t\t\ttempIndexForSmallest = j;\n\t\t\t} // Of if\n\t\t} // Of for j\n\n\t\t// Change the selected one with the current one.\n\t\tparaPtr->elements[tempIndexForSmallest] = paraPtr->elements[i];\n\t\tparaPtr->elements[i] = tempNode;\n\t} // Of for i\n}// Of selectionSort\n\n/**\n * Test the method.\n */\nvoid selectionSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore selection sort:\\r\\n\");\n\tprintList(tempList);\n\n\tselectionSort(tempList);\n\tprintf(\"\\r\\nAfter selection sort:\\r\\n\");\n\tprintList(tempList);\n}// Of selectionSortTest\n\n/**\n * Adjust heap.\n */\nvoid adjustHeap(ListPtr paraPtr, int paraStart, int paraLength) {\n\tNode tempNode = paraPtr->elements[paraStart];\n\tint tempParent = paraStart;\n\tint tempKey = paraPtr->elements[paraStart].key;\n\n\tfor (int tempChild = paraStart * 2 + 1; tempChild < paraLength; tempChild = tempChild * 2 + 1) {\n\t\t// The right child is bigger.\n\t\tif (tempChild + 1 < paraLength) {\n\t\t\tif (paraPtr->elements[tempChild].key < paraPtr->elements[tempChild + 1].key) {\n\t\t\t\ttempChild++;\n\t\t\t} // Of if\n\t\t} // Of if\n\n\t\t//System.out.println(\"The parent position is \" + tempParent + \" and the child is \" + tempChild);\n\t\tif (tempKey < paraPtr->elements[tempChild].key) {\n\t\t\t// The child is bigger.\n\t\t\tparaPtr->elements[tempParent] = paraPtr->elements[tempChild];\n\t\t\t//System.out.println(\"Move \" + paraPtr->elements[tempChild].key + \" to position \" + tempParent);\n\t\t\ttempParent = tempChild;\n\t\t} else {\n\t\t\tbreak;\n\t\t} // Of if\n\t} // Of for tempChild\n\n\tparaPtr->elements[tempParent] = tempNode;\n}// Of adjustHeap\n \n /**\n * Heap sort.\n */\nvoid heapSort(ListPtr paraPtr) {\n\tNode tempNode;\n\tint i;\n\t// Step 1. Construct the initial heap.\n\tfor (i = paraPtr->length / 2 - 1; i >= 0; i--) {\n\t\tadjustHeap(paraPtr, i, paraPtr->length);\n\t} // Of for i\n\n\t// Step 2. Swap and reconstruct.\n\tfor (i = paraPtr->length - 1; i > 0; i--) {\n\t\ttempNode = paraPtr->elements[0];\n\t\tparaPtr->elements[0] = paraPtr->elements[i];\n\t\tparaPtr->elements[i] = tempNode;\n\n\t\tadjustHeap(paraPtr, 0, i);\n\t\t//System.out.println(\"Round \" + (length - i) + \": \" + this);\n\t} // Of for i\n}// Of heapSort\n\n/**\n * Test the method.\n */\nvoid heapSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore heap sort:\\r\\n\");\n\tprintList(tempList);\n\n\theapSort(tempList);\n\tprintf(\"\\r\\nAfter heap sort:\\r\\n\");\n\tprintList(tempList);\n}// Of heapSortTest\n\n/**\n * Selection sort.\n */\nvoid mergeSort(ListPtr paraPtr) {\n\t// Step 1. Allocate space.\n\n\tint tempRow; // The current row\n\tint tempGroups; // Number of groups\n\tint tempActualRow; // Only 0 or 1\n\tint tempNextRow = 0;\n\tint tempGroupNumber;\n\tint tempFirstStart, tempSecondStart, tempSecondEnd;\n\tint tempFirstIndex, tempSecondIndex;\n\tint tempNumCopied;\n\tint i;\n\tint tempSize;\n\n\t/*\n\tListPtr tempMatrix[2];\n\tint* tempIntArray = (int*)malloc(paraPtr->length * sizeof(int));\n\tchar* tempCharArray = (char*)malloc(paraPtr->length * sizeof(char));\n\ttempMatrix[0] = paraPtr;\n\ttempMatrix[1] = initList(tempIntArray, tempCharArray, paraPtr->length);\n\t*/\n\n\tNode** tempMatrix = (Node**)malloc(2 * sizeof(Node*));\n\ttempMatrix[0] = (Node*)malloc(paraPtr->length * sizeof(Node));\n\ttempMatrix[1] = (Node*)malloc(paraPtr->length * sizeof(Node));\n\tfor (i = 0; i < paraPtr->length; i ++) {\n\t\ttempMatrix[0][i] = paraPtr->elements[i];\n\t}//Of for i\n\n\t/*\n\tNode tempMatrix[2][length];\n\n\t// Step 2. Copy data.\n\tfor (i = 0; i < length; i++) {\n\t\ttempMatrix[0][i] = data[i];\n\t} // Of for i\n\t*/\n\n\t// Step 3. Merge. log n rounds\n\ttempRow = -1;\n\tfor (tempSize = 1; tempSize <= paraPtr->length; tempSize *= 2) {\n\t\t// Reuse the space of the two rows.\n\t\ttempRow++;\n\t\t//System.out.println(\"Current row = \" + tempRow);\n\t\ttempActualRow = tempRow % 2;\n\t\ttempNextRow = (tempRow + 1) % 2;\n\n\t\ttempGroups = paraPtr->length / (tempSize * 2);\n\t\tif (paraPtr->length % (tempSize * 2) != 0) {\n\t\t\ttempGroups++;\n\t\t} // Of if\n\t\t//System.out.println(\"tempSize = \" + tempSize + \", numGroups = \" + tempGroups);\n\n\t\tfor (tempGroupNumber = 0; tempGroupNumber < tempGroups; tempGroupNumber++) {\n\t\t\ttempFirstStart = tempGroupNumber * tempSize * 2;\n\t\t\ttempSecondStart = tempGroupNumber * tempSize * 2 + tempSize;\n\t\t\tif (tempSecondStart > paraPtr->length - 1) {\n\t\t\t\t// Copy the first part.\n\t\t\t\tfor (i = tempFirstStart; i < paraPtr->length; i++) {\n\t\t\t\t\ttempMatrix[tempNextRow][i] = tempMatrix[tempActualRow][i];\n\t\t\t\t} // Of for i\n\t\t\t\tcontinue;\n\t\t\t} // Of if\n\t\t\ttempSecondEnd = tempGroupNumber * tempSize * 2 + tempSize * 2 - 1;\n\t\t\tif (tempSecondEnd > paraPtr->length - 1) {\n\t\t\t\ttempSecondEnd = paraPtr->length - 1;\n\t\t\t} // Of if\n\n\t\t\ttempFirstIndex = tempFirstStart;\n\t\t\ttempSecondIndex = tempSecondStart;\n\t\t\ttempNumCopied = 0;\n\t\t\twhile ((tempFirstIndex <= tempSecondStart - 1)\n\t\t\t\t\t&& (tempSecondIndex <= tempSecondEnd)) {\n\t\t\t\tif (tempMatrix[tempActualRow][tempFirstIndex].key <= tempMatrix[tempActualRow][tempSecondIndex].key) {\n\n\t\t\t\t\ttempMatrix[tempNextRow][tempFirstStart\n\t\t\t\t\t\t\t+ tempNumCopied] = tempMatrix[tempActualRow][tempFirstIndex];\n\t\t\t\t\ttempFirstIndex++;\n\t\t\t\t\t//System.out.println(\"copying \" + tempMatrix[tempActualRow][tempFirstIndex]);\n\t\t\t\t} else {\n\t\t\t\t\ttempMatrix[tempNextRow][tempFirstStart\n\t\t\t\t\t\t\t+ tempNumCopied] = tempMatrix[tempActualRow][tempSecondIndex];\n\t\t\t\t\t//System.out.println(\"copying \" + tempMatrix[tempActualRow][tempSecondIndex]);\n\t\t\t\t\ttempSecondIndex++;\n\t\t\t\t} // Of if\n\t\t\t\ttempNumCopied++;\n\t\t\t} // Of while\n\n\t\t\twhile (tempFirstIndex <= tempSecondStart - 1) {\n\t\t\t\ttempMatrix[tempNextRow][tempFirstStart\n\t\t\t\t\t\t+ tempNumCopied] = tempMatrix[tempActualRow][tempFirstIndex];\n\t\t\t\ttempFirstIndex++;\n\t\t\t\ttempNumCopied++;\n\t\t\t} // Of while\n\n\t\t\twhile (tempSecondIndex <= tempSecondEnd) {\n\t\t\t\ttempMatrix[tempNextRow][tempFirstStart\n\t\t\t\t\t\t+ tempNumCopied] = tempMatrix[tempActualRow][tempSecondIndex];\n\t\t\t\ttempSecondIndex++;\n\t\t\t\ttempNumCopied++;\n\t\t\t} // Of while\n\t\t} // Of for groupNumber\n\n\t} // Of for tempStepSize\n\n\tfor (i = 0; i < paraPtr->length; i ++) {\n\t\tparaPtr->elements[i] = tempMatrix[tempNextRow][i];\n\t}//Of for i\n}// Of mergeSort\n\n/**\n * Test the method.\n */\nvoid mergeSortTest() {\n\tint tempUnsortedKeys[] = {5, 3, 6, 10, 7, 1, 9 };\n\tchar tempContents[] = {'i', 't', 'e', 's', 'c', 'f', 'w' };\n\tListPtr tempList = initList(tempUnsortedKeys, tempContents, 7);\n\n\tprintf(\"\\r\\nBefore merge sort:\\r\\n\");\n\tprintList(tempList);\n\n\tmergeSort(tempList);\n\tprintf(\"\\r\\nAfter merge sort:\\r\\n\");\n\tprintList(tempList);\n}// Of mergeSortTest\n \n /**\n * The entrance of the program.\n */\nint main() {\n\tinsertionSortTest();\n\t//shellSortTest();\n\t//bubbleSortTest();\n\t//quickSortTest();\n\t//selectionSortTest();\n\t//heapSortTest();\n\t//mergeSortTest();\n\treturn 1;\n}// Of main\n\n\n\n"})})]})}function d(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>o});var r=n(6540);const i={},p=r.createContext(i);function a(t){const e=r.useContext(p);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function o(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:a(t.components),r.createElement(p.Provider,{value:e},t.children)}}}]);