"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4171],{6212:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=e(4848),r=e(8453);const s={},a="\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5",o={id:"DataStructer/\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5",title:"\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5",description:"Prim\u7b97\u6cd5",source:"@site/docs/DataStructer/\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5.md",sourceDirName:"DataStructer",slug:"/DataStructer/\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5",permalink:"/docs/DataStructer/\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"DataStructerSidebar",previous:{title:"\u6570\u636e\u7ed3\u678415-\u56fe\u7684\u904d\u5386",permalink:"/docs/DataStructer/\u6570\u636e\u7ed3\u678415-\u56fe\u7684\u904d\u5386"},next:{title:"\u6570\u636e\u7ed3\u678417-\u987a\u5e8f\u67e5\u627e\u4e0e\u4e8c\u5206\u67e5\u627e",permalink:"/docs/DataStructer/\u6570\u636e\u7ed3\u678417-\u987a\u5e8f\u67e5\u627e\u4e0e\u4e8c\u5206\u67e5\u627e"}},d={},l=[{value:"Prim\u7b97\u6cd5",id:"prim\u7b97\u6cd5",level:2},{value:"1. \u6570\u636e\u7ed3\u6784",id:"1-\u6570\u636e\u7ed3\u6784",level:3},{value:"2. \u7b97\u6cd5\u6b65\u9aa4",id:"2-\u7b97\u6cd5\u6b65\u9aa4",level:3},{value:"3. \u4ee3\u7801\u5b9e\u73b0",id:"3-\u4ee3\u7801\u5b9e\u73b0",level:3},{value:"Dijkstra\u7b97\u6cd5",id:"dijkstra\u7b97\u6cd5",level:2},{value:"1. \u6570\u636e\u7ed3\u6784",id:"1-\u6570\u636e\u7ed3\u6784-1",level:3},{value:"2. \u7b97\u6cd5\u6b65\u9aa4",id:"2-\u7b97\u6cd5\u6b65\u9aa4-1",level:3},{value:"3. \u4ee3\u7801\u5b9e\u73b0",id:"3-\u4ee3\u7801\u5b9e\u73b0-1",level:3},{value:"\u95f5\u5e06\u8001\u5e08\u5199\u7684",id:"\u95f5\u5e06\u8001\u5e08\u5199\u7684",level:2},{value:"\u4ee3\u7801",id:"\u4ee3\u7801",level:3},{value:"\u8fd0\u884c\u7ed3\u679c",id:"\u8fd0\u884c\u7ed3\u679c",level:3}];function c(t){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-prim\u7b97\u6cd5\u4e0edijkstra\u7b97\u6cd5",children:"\u6570\u636e\u7ed3\u678416-\u56fe\u7684\u904d\u5386-Prim\u7b97\u6cd5\u4e0eDijkstra\u7b97\u6cd5"}),"\n",(0,i.jsx)(n.h2,{id:"prim\u7b97\u6cd5",children:"Prim\u7b97\u6cd5"}),"\n",(0,i.jsx)(n.p,{children:"Prim\u7b97\u6cd5\u7528\u4e8e\u6c42\u89e3\u52a0\u6743\u65e0\u5411\u56fe\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002\u5b83\u7684\u57fa\u672c\u601d\u60f3\u662f\u4ece\u4e00\u4e2a\u9876\u70b9\u5f00\u59cb\uff0c\u9010\u6b65\u6269\u5c55\u6700\u5c0f\u751f\u6210\u6811\uff0c\u76f4\u5230\u5305\u62ec\u6240\u6709\u9876\u70b9\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"1-\u6570\u636e\u7ed3\u6784",children:"1. \u6570\u636e\u7ed3\u6784"}),"\n",(0,i.jsx)(n.p,{children:"\u6211\u4eec\u9700\u8981\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u56fe\u7684\u90bb\u63a5\u77e9\u9635\u8868\u793a"}),"\n",(0,i.jsx)(n.li,{children:"\u5b58\u50a8\u6700\u5c0f\u751f\u6210\u6811\u7684\u6570\u7ec4"}),"\n",(0,i.jsx)(n.li,{children:"\u6807\u8bb0\u5df2\u5305\u542b\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u7684\u9876\u70b9\u7684\u5e03\u5c14\u6570\u7ec4"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-\u7b97\u6cd5\u6b65\u9aa4",children:"2. \u7b97\u6cd5\u6b65\u9aa4"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u521d\u59cb\u5316\uff1a\u9009\u62e9\u4e00\u4e2a\u9876\u70b9\u4f5c\u4e3a\u8d77\u70b9\uff0c\u8bbe\u7f6e\u5176\u6743\u91cd\u4e3a0\uff0c\u5176\u4ed6\u9876\u70b9\u7684\u6743\u91cd\u4e3a\u65e0\u7a77\u5927\u3002"}),"\n",(0,i.jsxs)(n.li,{children:["\u91cd\u590d\u4ee5\u4e0b\u6b65\u9aa4\u76f4\u5230\u6240\u6709\u9876\u70b9\u90fd\u5305\u542b\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e2d\uff1a","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u4ece\u672a\u5305\u542b\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u7684\u9876\u70b9\u4e2d\u9009\u62e9\u6743\u91cd\u6700\u5c0f\u7684\u9876\u70b9\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u5c06\u8be5\u9876\u70b9\u52a0\u5165\u6700\u5c0f\u751f\u6210\u6811\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u66f4\u65b0\u4e0e\u8be5\u9876\u70b9\u76f8\u90bb\u7684\u9876\u70b9\u7684\u6743\u91cd\u3002"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-\u4ee3\u7801\u5b9e\u73b0",children:"3. \u4ee3\u7801\u5b9e\u73b0"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define V 5  // \u56fe\u7684\u9876\u70b9\u6570\n\n// \u627e\u5230\u6743\u503c\u6700\u5c0f\u4e14\u672a\u5305\u542b\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u7684\u9876\u70b9\nint minKey(int key[], bool mstSet[]) {\n    int min = INT_MAX, min_index;\n\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == false && key[v] < min)\n            min = key[v], min_index = v;\n\n    return min_index;\n}\n\n// \u6253\u5370\u6784\u5efa\u7684\u6700\u5c0f\u751f\u6210\u6811\nvoid printMST(int parent[], int graph[V][V]) {\n    printf("Edge \\tWeight\\n");\n    for (int i = 1; i < V; i++)\n        printf("%d - %d \\t%d \\n", parent[i], i, graph[i][parent[i]]);\n}\n\n// \u5229\u7528Prim\u7b97\u6cd5\u6784\u5efa\u6700\u5c0f\u751f\u6210\u6811\nvoid primMST(int graph[V][V]) {\n    int parent[V];  // \u5b58\u50a8\u6784\u5efa\u7684\u6700\u5c0f\u751f\u6210\u6811\n    int key[V];     // \u7528\u4e8e\u9009\u62e9\u6700\u5c0f\u6743\u91cd\u7684\u8fb9\n    bool mstSet[V]; // \u6807\u8bb0\u5df2\u5305\u542b\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u7684\u9876\u70b9\n\n    // \u521d\u59cb\u5316\u6240\u6709\u952e\u503c\u4e3a\u65e0\u7a77\u5927\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n\n    // \u9009\u62e9\u7b2c\u4e00\u4e2a\u9876\u70b9\u4f5c\u4e3a\u8d77\u70b9\n    key[0] = 0;\n    parent[0] = -1; // \u8d77\u70b9\u6ca1\u6709\u7236\u8282\u70b9\n\n    // \u6784\u5efa\u6700\u5c0f\u751f\u6210\u6811\n    for (int count = 0; count < V - 1; count++) {\n        int u = minKey(key, mstSet);\n\n        mstSet[u] = true;\n\n        for (int v = 0; v < V; v++)\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n\n    printMST(parent, graph);\n}\n\nint main() {\n    int graph[V][V] = {{0, 2, 0, 6, 0},\n                       {2, 0, 3, 8, 5},\n                       {0, 3, 0, 0, 7},\n                       {6, 8, 0, 0, 9},\n                       {0, 5, 7, 9, 0}};\n\n    primMST(graph);\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"dijkstra\u7b97\u6cd5",children:"Dijkstra\u7b97\u6cd5"}),"\n",(0,i.jsx)(n.p,{children:"Dijkstra\u7b97\u6cd5\u7528\u4e8e\u6c42\u89e3\u52a0\u6743\u6709\u5411\u56fe\u7684\u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898\u3002\u5b83\u7684\u57fa\u672c\u601d\u60f3\u662f\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u9010\u6b65\u6269\u5c55\u6700\u77ed\u8def\u5f84\uff0c\u76f4\u5230\u6240\u6709\u9876\u70b9\u90fd\u88ab\u5904\u7406\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"1-\u6570\u636e\u7ed3\u6784-1",children:"1. \u6570\u636e\u7ed3\u6784"}),"\n",(0,i.jsx)(n.p,{children:"\u6211\u4eec\u9700\u8981\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u56fe\u7684\u90bb\u63a5\u77e9\u9635\u8868\u793a"}),"\n",(0,i.jsx)(n.li,{children:"\u5b58\u50a8\u6700\u77ed\u8def\u5f84\u7684\u6570\u7ec4"}),"\n",(0,i.jsx)(n.li,{children:"\u6807\u8bb0\u5df2\u5904\u7406\u9876\u70b9\u7684\u5e03\u5c14\u6570\u7ec4"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-\u7b97\u6cd5\u6b65\u9aa4-1",children:"2. \u7b97\u6cd5\u6b65\u9aa4"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u521d\u59cb\u5316\uff1a\u8bbe\u7f6e\u8d77\u70b9\u7684\u8ddd\u79bb\u4e3a0\uff0c\u5176\u4ed6\u9876\u70b9\u7684\u8ddd\u79bb\u4e3a\u65e0\u7a77\u5927\u3002"}),"\n",(0,i.jsxs)(n.li,{children:["\u91cd\u590d\u4ee5\u4e0b\u6b65\u9aa4\u76f4\u5230\u6240\u6709\u9876\u70b9\u90fd\u88ab\u5904\u7406\uff1a","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u4ece\u672a\u5904\u7406\u7684\u9876\u70b9\u4e2d\u9009\u62e9\u8ddd\u79bb\u6700\u5c0f\u7684\u9876\u70b9\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u5c06\u8be5\u9876\u70b9\u6807\u8bb0\u4e3a\u5df2\u5904\u7406\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u66f4\u65b0\u4e0e\u8be5\u9876\u70b9\u76f8\u90bb\u7684\u9876\u70b9\u7684\u8ddd\u79bb\u3002"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-\u4ee3\u7801\u5b9e\u73b0-1",children:"3. \u4ee3\u7801\u5b9e\u73b0"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define V 9  // \u56fe\u7684\u9876\u70b9\u6570\n\n// \u627e\u5230\u8ddd\u79bb\u6700\u5c0f\u4e14\u672a\u5904\u7406\u7684\u9876\u70b9\nint minDistance(int dist[], bool sptSet[]) {\n    int min = INT_MAX, min_index;\n\n    for (int v = 0; v < V; v++)\n        if (sptSet[v] == false && dist[v] <= min)\n            min = dist[v], min_index = v;\n\n    return min_index;\n}\n\n// \u6253\u5370\u4ece\u8d77\u70b9\u5230\u5176\u4ed6\u6240\u6709\u9876\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\nvoid printSolution(int dist[]) {\n    printf("Vertex \\t Distance from Source\\n");\n    for (int i = 0; i < V; i++)\n        printf("%d \\t\\t %d\\n", i, dist[i]);\n}\n\n// \u5229\u7528Dijkstra\u7b97\u6cd5\u8ba1\u7b97\u4ecesrc\u5230\u6240\u6709\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\nvoid dijkstra(int graph[V][V], int src) {\n    int dist[V];    // \u5b58\u50a8\u4ece\u8d77\u70b9\u5230\u5404\u9876\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\n    bool sptSet[V]; // \u6807\u8bb0\u5df2\u5904\u7406\u9876\u70b9\n\n    // \u521d\u59cb\u5316\u6240\u6709\u8ddd\u79bb\u4e3a\u65e0\u7a77\u5927\n    for (int i = 0; i < V; i++)\n        dist[i] = INT_MAX, sptSet[i] = false;\n\n    // \u8d77\u70b9\u7684\u8ddd\u79bb\u4e3a0\n    dist[src] = 0;\n\n    // \u627e\u5230\u4ece\u8d77\u70b9\u5230\u6240\u6709\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\n    for (int count = 0; count < V - 1; count++) {\n        int u = minDistance(dist, sptSet);\n\n        sptSet[u] = true;\n\n        for (int v = 0; v < V; v++)\n            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n\n    printSolution(dist);\n}\n\nint main() {\n    int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n                       {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                       {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                       {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                       {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                       {0, 0, 4, 14, 10, 0, 2, 0, 0},\n                       {0, 0, 0, 0, 0, 2, 0, 1, 6},\n                       {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                       {0, 0, 2, 0, 0, 0, 6, 7, 0}};\n\n    dijkstra(graph, 0);\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"\u95f5\u5e06\u8001\u5e08\u5199\u7684",children:"\u95f5\u5e06\u8001\u5e08\u5199\u7684"}),"\n",(0,i.jsx)(n.h3,{id:"\u4ee3\u7801",children:"\u4ee3\u7801"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <malloc.h>\n\n#define MAX_DISTANCE 10000\n\n/**\n * The structure of a Net.\n */\ntypedef struct Net {\n\tint** weights;\n\tint numNodes;\n} Net, *NetPtr;\n\n/**\n * Initialize a Net.\n */\nNetPtr initNet(int paraSize, int** paraData) {\n\tint i, j;\n\tNetPtr resultPtr = (NetPtr)malloc(sizeof(Net));\n\tresultPtr -> numNodes = paraSize;\n\n\t//Two stage space allocation.\n\tresultPtr->weights = (int**)malloc(paraSize * sizeof(int*));\n\tfor (i = 0; i < paraSize; i ++) {\n\t\tresultPtr -> weights[i] = (int*)malloc(paraSize * sizeof(int));\n\t\tfor (j = 0; j < paraSize; j ++) {\n\t\t\tresultPtr -> weights[i][j] = paraData[i][j];\n\t\t}//Of for j\n\t}//Of for i\n\t\n\treturn resultPtr;\n}//Of initNet\n\n/**\n * The Prim algorithm for spanning tree, or the Dijkstra algorithm for nearest path.\n * @param paraAlgorithm 0 for Dijkstra, 1 for Prim\n * @return The total cost of the tree.\n */\nint dijkstraOrPrim(NetPtr paraPtr, int paraAlgorithm) {\n\tint i, j, minDistance, tempBestNode, resultCost;\n\tint source = 0;\n\tint numNodes = paraPtr->numNodes;\n\tint *distanceArray = (int*)malloc(numNodes * sizeof(int));\n\tint *parentArray = (int*)malloc(numNodes * sizeof(int));\n\t//Essentially boolean\n\tint *visitedArray = (int*)malloc(numNodes * sizeof(int)); \n\n\t// Step 1. Initialize. Any node can be the source.\n\tfor (i = 0; i < numNodes; i++) {\n\t\tdistanceArray[i] = paraPtr->weights[source][i];\n\t\tparentArray[i] = source;\n\t\tvisitedArray[i] = 0;\n\t} // Of for i\n\tdistanceArray[source] = 0;\n\tparentArray[source] = -1;\n\tvisitedArray[source] = 1;\n\n\t// Step 2. Main loops.\n\ttempBestNode = -1;\n\tfor (i = 0; i < numNodes - 1; i++) {\n\t\t// Step 2.1 Find out the best next node.\n\t\tminDistance = MAX_DISTANCE;\n\t\tfor (j = 0; j < numNodes; j++) {\n\t\t\t// This node is visited.\n\t\t\tif (visitedArray[j]) {\n\t\t\t\tcontinue;\n\t\t\t} // Of if\n\n\t\t\tif (minDistance > distanceArray[j]) {\n\t\t\t\tminDistance = distanceArray[j];\n\t\t\t\ttempBestNode = j;\n\t\t\t} // Of if\n\t\t} // Of for j\n\n\t\tvisitedArray[tempBestNode] = 1;\n\n\t\t// Step 2.2 Prepare for the next round.\n\t\tfor (j = 0; j < numNodes; j++) {\n\t\t\t// This node is visited.\n\t\t\tif (visitedArray[j]) {\n\t\t\t\tcontinue;\n\t\t\t} // Of if\n\n\t\t\t// This node cannot be reached.\n\t\t\tif (paraPtr->weights[tempBestNode][j] >= MAX_DISTANCE) {\n\t\t\t\tcontinue;\n\t\t\t} // Of if\n\n\t\t\t// Attention: the difference between Dijkstra and Prim algorithms.\n\t\t\tif (paraAlgorithm == 0) {\n\t\t\t\tif (distanceArray[j] > distanceArray[tempBestNode] + paraPtr->weights[tempBestNode][j]) {\n\t\t\t\t\t// Change the distance.\n\t\t\t\t\tdistanceArray[j] = distanceArray[tempBestNode] + paraPtr->weights[tempBestNode][j];\n\t\t\t\t\t// Change the parent.\n\t\t\t\t\tparentArray[j] = tempBestNode;\n\t\t\t\t} // Of if\n\t\t\t} else {\n\t\t\t\tif (distanceArray[j] > paraPtr->weights[tempBestNode][j]) {\n\t\t\t\t\t// Change the distance.\n\t\t\t\t\tdistanceArray[j] = paraPtr->weights[tempBestNode][j];\n\t\t\t\t\t// Change the parent.\n\t\t\t\t\tparentArray[j] = tempBestNode;\n\t\t\t\t} // Of if\n\t\t\t}//Of if\n\t\t} // Of for j\n\t} // Of for i\n\n\tprintf("the parent of each node: ");\n\tfor (i = 0; i < numNodes; i++) {\n\t\tprintf("%d, ", parentArray[i]);\n\t} // Of for i\n\n\tif (paraAlgorithm == 0) {\n\t\tprintf("From node 0, path length to all nodes are: ");\n\t\tfor (i = 0; i < numNodes; i++) {\n\t\t\tprintf("%d (%d), ", i, distanceArray[i]);\n\t\t} // Of for i\n\t} else {\n\t\tresultCost = 0;\n\t\tfor (i = 0; i < numNodes; i++) {\n\t\t\tresultCost += distanceArray[i];\n\t\t\tprintf("cost of node %d is %d, total = %d\\r\\n", i, distanceArray[i], resultCost);\n\t\t} // Of for i\n\t\tprintf("Finally, the total cost is %d.\\r\\n ", resultCost);\n\t}//Of if\n\n\t// Step 3. Output for debug.\n\tprintf("\\r\\n");\n\n\treturn resultCost;\n}// Of dijkstraOrPrim\n\n/**\n * Construct a sample net.\n * Revised from testGraphTranverse().\n */\nNetPtr constructSampleNet() {\n\tint i, j;\n\tint myGraph[6][6] = { \n\t\t{0, 6, 1, 5, 0, 0},\n\t\t{6, 0, 5, 0, 3, 0}, \n\t\t{1, 5, 0, 5, 6, 4}, \n\t\t{5, 0, 5, 0, 0, 2}, \n\t\t{0, 3, 6, 0, 0, 6},\n\t\t{0, 0, 4, 2, 6, 0}};\n\tint** tempPtr;\n\tint numNodes = 6;\n\tprintf("Preparing data\\r\\n");\n\t\t\n\ttempPtr = (int**)malloc(numNodes * sizeof(int*));\n\tfor (i = 0; i < numNodes; i ++) {\n\t\ttempPtr[i] = (int*)malloc(numNodes * sizeof(int));\n\t}//Of for i\n\t \n\tfor (i = 0; i < numNodes; i ++) {\n\t\tfor (j = 0; j < numNodes; j ++) {\n\t\t\tif (myGraph[i][j] == 0) {\n\t\t\t\ttempPtr[i][j] = MAX_DISTANCE;\n\t\t\t} else {\n\t\t\t\ttempPtr[i][j] = myGraph[i][j];\n\t\t\t}//Of if\n\t\t}//Of for j\n\t}//Of for i\n \n\tprintf("Data ready\\r\\n");\n\t\n\tNetPtr resultNetPtr = initNet(numNodes, tempPtr);\n\treturn resultNetPtr;\n}//Of constructSampleNet\n\n/**\n * Test the Prim algorithm.\n */\nvoid testPrim() {\n\tNetPtr tempNetPtr = constructSampleNet();\n\tprintf("=====Dijkstra algorithm=====\\r\\n");\n\tdijkstraOrPrim(tempNetPtr, 0);\n\tprintf("=====Prim algorithm=====\\r\\n");\n\tdijkstraOrPrim(tempNetPtr, 1);\n}//Of testPrim\n\n/**\n * The entrance.\n */\nint main(){\n\ttestPrim();\n\treturn 1;\n}//Of main\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\u8fd0\u884c\u7ed3\u679c",children:"\u8fd0\u884c\u7ed3\u679c"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Preparing data\nData ready\n=====Dijkstra algorithm=====\nthe parent of each node: -1, 0, 0, 0, 2, 2, From node 0, path length to all nodes are: 0 (0), 1 (6), 2 (1), 3 (5), 4 (7), 5 (5),\n=====Prim algorithm=====\nthe parent of each node: -1, 2, 0, 5, 1, 2, cost of node 0 is 0, total = 0\ncost of node 1 is 5, total = 5\ncost of node 2 is 1, total = 6\ncost of node 3 is 2, total = 8\ncost of node 4 is 3, total = 11\ncost of node 5 is 4, total = 15\nFinally, the total cost is 15.\n\nPress any key to continue\n\n"})})]})}function p(t={}){const{wrapper:n}={...(0,r.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(c,{...t})}):c(t)}},8453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>o});var i=e(6540);const r={},s=i.createContext(r);function a(t){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:a(t.components),i.createElement(s.Provider,{value:n},t.children)}}}]);